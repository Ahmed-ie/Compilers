/*
 * MiniC Optimizer (Part 3)
 * Author: Ahmed Elmi
 * Term: Winter 2026
 * Date: February 17, 2026
 *
 * Implements local (CSE, DCE, constant folding) and global (constant propagation)
 * optimizations over LLVM IR generated by clang for MiniC programs.
 */

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <unordered_map>
#include <unordered_set>
#include <vector>

#include <llvm-c/Core.h>
#include <llvm-c/IRReader.h>
#include <llvm-c/Support.h>

static bool is_arith_opcode(LLVMOpcode op) {
    return op == LLVMAdd || op == LLVMSub || op == LLVMMul;
}

// Key used to identify common subexpressions by opcode + operands.
struct InstKey {
    LLVMOpcode op;
    std::vector<LLVMValueRef> operands;
};

// Hash for InstKey so it can be used in unordered_map.
struct InstKeyHash {
    std::size_t operator()(const InstKey &k) const noexcept {
        std::size_t h = static_cast<std::size_t>(k.op);
        for (auto *v : k.operands) {
            h ^= reinterpret_cast<std::uintptr_t>(v) + 0x9e3779b9 + (h << 6) + (h >> 2);
        }
        return h;
    }
};

// Equality for InstKey so it can be used in unordered_map.
struct InstKeyEq {
    bool operator()(const InstKey &a, const InstKey &b) const noexcept {
        if (a.op != b.op || a.operands.size() != b.operands.size()) {
            return false;
        }
        for (size_t i = 0; i < a.operands.size(); ++i) {
            if (a.operands[i] != b.operands[i]) {
                return false;
            }
        }
        return true;
    }
};

// Constant-fold integer add/sub/mul instructions with constant operands.
// Params:
// - module: LLVM module to scan and mutate.
// Returns: true if any instruction was folded.
static bool constant_fold_module(LLVMModuleRef module) {
    bool changed = false;

    for (LLVMValueRef func = LLVMGetFirstFunction(module); func; func = LLVMGetNextFunction(func)) {
        for (LLVMBasicBlockRef bb = LLVMGetFirstBasicBlock(func); bb; bb = LLVMGetNextBasicBlock(bb)) {
            LLVMValueRef inst = LLVMGetFirstInstruction(bb);
            while (inst) {
                LLVMValueRef next = LLVMGetNextInstruction(inst);
                LLVMOpcode op = LLVMGetInstructionOpcode(inst);

                if (is_arith_opcode(op)) {
                    if (LLVMGetNumOperands(inst) == 2) {
                        LLVMValueRef lhs = LLVMGetOperand(inst, 0);
                        LLVMValueRef rhs = LLVMGetOperand(inst, 1);
                        if (LLVMIsAConstantInt(lhs) && LLVMIsAConstantInt(rhs)) {
                            // LLVM 21 C API lacks LLVMConstMul, so i compute the result in C++.
                            int64_t lval = LLVMConstIntGetSExtValue(lhs);
                            int64_t rval = LLVMConstIntGetSExtValue(rhs);
                            int64_t res = 0;

                            if (op == LLVMAdd) {
                                res = lval + rval;
                            } else if (op == LLVMSub) {
                                res = lval - rval;
                            } else if (op == LLVMMul) {
                                res = lval * rval;
                            }

                            LLVMTypeRef ty = LLVMTypeOf(lhs);
                            LLVMValueRef folded = LLVMConstInt(ty, static_cast<uint64_t>(res), 1);
                            LLVMReplaceAllUsesWith(inst, folded);
                            LLVMInstructionEraseFromParent(inst);
                            changed = true;
                        }
                    }
                }

                inst = next;
            }
        }
    }

    return changed;
}

// Check whether an instruction is eligible for CSE.
// Params:
// - inst: instruction to test.
// Returns: true if instruction can be considered for CSE.
static bool is_cse_candidate(LLVMValueRef inst) {
    LLVMOpcode op = LLVMGetInstructionOpcode(inst);
    if (op == LLVMCall || op == LLVMInvoke || op == LLVMStore || op == LLVMAlloca) {
        return false;
    }
    if (op == LLVMRet || op == LLVMBr || op == LLVMSwitch || op == LLVMIndirectBr ||
        op == LLVMUnreachable) {
        return false;
    }
    return true;
}

// Perform common subexpression elimination per basic block.
// Params:
// - module: LLVM module to scan and mutate.
// Returns: true if any replacement occurred.
static bool common_subexpr_elim_module(LLVMModuleRef module) {
    bool changed = false;

    for (LLVMValueRef func = LLVMGetFirstFunction(module); func; func = LLVMGetNextFunction(func)) {
        for (LLVMBasicBlockRef bb = LLVMGetFirstBasicBlock(func); bb; bb = LLVMGetNextBasicBlock(bb)) {
            std::unordered_map<InstKey, LLVMValueRef, InstKeyHash, InstKeyEq> exprs;
            std::unordered_map<LLVMValueRef, LLVMValueRef> last_load_for_ptr;

            for (LLVMValueRef inst = LLVMGetFirstInstruction(bb); inst;
                 inst = LLVMGetNextInstruction(inst)) {
                LLVMOpcode op = LLVMGetInstructionOpcode(inst);

                if (op == LLVMStore) {
                    LLVMValueRef ptr = LLVMGetOperand(inst, 1);
                    // Any store can invalidate a previous load from the same pointer in this block.
                    last_load_for_ptr.erase(ptr);
                    continue;
                }

                if (!is_cse_candidate(inst)) {
                    continue;
                }

                if (op == LLVMLoad) {
                    LLVMValueRef ptr = LLVMGetOperand(inst, 0);
                    auto it = last_load_for_ptr.find(ptr);
                    if (it != last_load_for_ptr.end()) {
                        LLVMReplaceAllUsesWith(inst, it->second);
                        changed = true;
                    } else {
                        last_load_for_ptr[ptr] = inst;
                    }
                    continue;
                }

                unsigned num_ops = LLVMGetNumOperands(inst);
                InstKey key;
                key.op = op;
                key.operands.reserve(num_ops);
                for (unsigned i = 0; i < num_ops; ++i) {
                    key.operands.push_back(LLVMGetOperand(inst, i));
                }

                auto it = exprs.find(key);
                if (it != exprs.end()) {
                    LLVMReplaceAllUsesWith(inst, it->second);
                    changed = true;
                } else {
                    exprs.emplace(std::move(key), inst);
                }
            }
        }
    }

    return changed;
}

// Check whether an instruction has side effects and must be kept.
// Params:
// - inst: instruction to test.
// Returns: true if instruction should not be removed.
static bool is_side_effecting(LLVMValueRef inst) {
    LLVMOpcode op = LLVMGetInstructionOpcode(inst);
    if (op == LLVMStore || op == LLVMCall || op == LLVMInvoke || op == LLVMAlloca) {
        // Keeping allocas to match expected outputn here; removing them can change SSA numbering/structure.
        return true;
    }
    if (op == LLVMRet || op == LLVMBr || op == LLVMSwitch || op == LLVMIndirectBr ||
        op == LLVMUnreachable) {
        return true;
    }
    return false;
}

// Dead code elimination: remove instructions with no uses and no side effects.
// Params:
// - module: LLVM module to scan and mutate.
// Returns: true if any instruction was removed.
static bool dead_code_elim_module(LLVMModuleRef module) {
    bool changed = false;

    for (LLVMValueRef func = LLVMGetFirstFunction(module); func; func = LLVMGetNextFunction(func)) {
        for (LLVMBasicBlockRef bb = LLVMGetFirstBasicBlock(func); bb; bb = LLVMGetNextBasicBlock(bb)) {
            LLVMValueRef inst = LLVMGetFirstInstruction(bb);
            while (inst) {
                LLVMValueRef next = LLVMGetNextInstruction(inst);
                if (LLVMGetFirstUse(inst) == nullptr && !is_side_effecting(inst)) {
                    LLVMInstructionEraseFromParent(inst);
                    changed = true;
                }
                inst = next;
            }
        }
    }

    return changed;
}

// Set ModuleID to a stable value based on input filename.
// Params:
// - module: LLVM module to modify.
// - input_path: original file path used as input.
static void set_module_id_from_input(LLVMModuleRef module, const char *input_path) {
    const char *base = std::strrchr(input_path, '/');
    base = base ? base + 1 : input_path;
    std::string id = std::string("opt_tests/") + base;
    // Normalize ModuleID so diffs are stable across input paths.
    LLVMSetModuleIdentifier(module, id.c_str(), id.size());
}

// Compare two store instructions by their pointer operand.
// Params:
// - a: first store instruction.
// - b: second store instruction.
// Returns: true if both store to the same pointer.
static bool same_store_target(LLVMValueRef a, LLVMValueRef b) {
    return LLVMGetOperand(a, 1) == LLVMGetOperand(b, 1);
}

// Check if a store instruction stores a constant integer.
// Params:
// - store_inst: store instruction.
// Returns: true if value operand is a constant int.
static bool is_constant_store(LLVMValueRef store_inst) {
    LLVMValueRef val = LLVMGetOperand(store_inst, 0);
    return LLVMIsAConstantInt(val) != nullptr;
}

// Constant propagation using store-load dataflow (GEN/KILL/IN/OUT).
// Params:
// - module: LLVM module to scan and mutate.
// Returns: true if any load was replaced by a constant.
static bool constant_propagation_module(LLVMModuleRef module) {
    bool changed = false;

    for (LLVMValueRef func = LLVMGetFirstFunction(module); func; func = LLVMGetNextFunction(func)) {
        if (LLVMIsDeclaration(func)) {
            continue;
        }

        std::vector<LLVMBasicBlockRef> blocks;
        std::unordered_map<LLVMBasicBlockRef, size_t> block_index;
        for (LLVMBasicBlockRef bb = LLVMGetFirstBasicBlock(func); bb; bb = LLVMGetNextBasicBlock(bb)) {
            block_index[bb] = blocks.size();
            blocks.push_back(bb);
        }

        std::vector<LLVMValueRef> all_stores;
        for (LLVMBasicBlockRef bb : blocks) {
            for (LLVMValueRef inst = LLVMGetFirstInstruction(bb); inst;
                 inst = LLVMGetNextInstruction(inst)) {
                if (LLVMGetInstructionOpcode(inst) == LLVMStore) {
                    all_stores.push_back(inst);
                }
            }
        }

        std::vector<std::unordered_set<LLVMValueRef>> gen(blocks.size());
        std::vector<std::unordered_set<LLVMValueRef>> kill(blocks.size());
        std::vector<std::unordered_set<LLVMValueRef>> in(blocks.size());
        std::vector<std::unordered_set<LLVMValueRef>> out(blocks.size());

        for (size_t i = 0; i < blocks.size(); ++i) {
            LLVMBasicBlockRef bb = blocks[i];
            auto &gen_set = gen[i];
            for (LLVMValueRef inst = LLVMGetFirstInstruction(bb); inst;
                 inst = LLVMGetNextInstruction(inst)) {
                if (LLVMGetInstructionOpcode(inst) == LLVMStore) {
                    for (auto it = gen_set.begin(); it != gen_set.end();) {
                        if (same_store_target(*it, inst)) {
                            it = gen_set.erase(it);
                        } else {
                            ++it;
                        }
                    }
                    gen_set.insert(inst);
                }
            }
        }

        for (size_t i = 0; i < blocks.size(); ++i) {
            LLVMBasicBlockRef bb = blocks[i];
            auto &kill_set = kill[i];
            for (LLVMValueRef inst = LLVMGetFirstInstruction(bb); inst;
                 inst = LLVMGetNextInstruction(inst)) {
                if (LLVMGetInstructionOpcode(inst) == LLVMStore) {
                    for (auto *s : all_stores) {
                        if (s != inst && same_store_target(s, inst)) {
                            kill_set.insert(s);
                        }
                    }
                }
            }
        }

        for (size_t i = 0; i < blocks.size(); ++i) {
            out[i] = gen[i];
        }

        bool changed_fp = true;
        while (changed_fp) {
            changed_fp = false;
            for (size_t i = 0; i < blocks.size(); ++i) {
                LLVMBasicBlockRef bb = blocks[i];
                std::unordered_set<LLVMValueRef> new_in;

                for (LLVMBasicBlockRef pred = LLVMGetFirstBasicBlock(func); pred;
                     pred = LLVMGetNextBasicBlock(pred)) {
                    LLVMValueRef term = LLVMGetBasicBlockTerminator(pred);
                    unsigned num_succ = term ? LLVMGetNumSuccessors(term) : 0;
                    for (unsigned s = 0; s < num_succ; ++s) {
                        if (LLVMGetSuccessor(term, s) == bb) {
                            size_t pi = block_index[pred];
                            new_in.insert(out[pi].begin(), out[pi].end());
                        }
                    }
                }

                std::unordered_set<LLVMValueRef> new_out = gen[i];
                for (auto *v : new_in) {
                    if (kill[i].find(v) == kill[i].end()) {
                        new_out.insert(v);
                    }
                }

                if (new_in != in[i] || new_out != out[i]) {
                    in[i] = std::move(new_in);
                    out[i] = std::move(new_out);
                    changed_fp = true;
                }
            }
        }

        std::vector<LLVMValueRef> loads_to_delete;

        for (size_t i = 0; i < blocks.size(); ++i) {
            LLVMBasicBlockRef bb = blocks[i];
            std::unordered_set<LLVMValueRef> R = in[i];

            for (LLVMValueRef inst = LLVMGetFirstInstruction(bb); inst;
                 inst = LLVMGetNextInstruction(inst)) {
                LLVMOpcode op = LLVMGetInstructionOpcode(inst);
                if (op == LLVMStore) {
                    for (auto it = R.begin(); it != R.end();) {
                        if (same_store_target(*it, inst)) {
                            it = R.erase(it);
                        } else {
                            ++it;
                        }
                    }
                    R.insert(inst);
                } else if (op == LLVMLoad) {
                    LLVMValueRef ptr = LLVMGetOperand(inst, 0);
                    bool saw_store = false;
                    bool all_const = true;
                    int64_t const_val = 0;
                    bool const_init = false;

                    for (auto *s : R) {
                        if (LLVMGetOperand(s, 1) == ptr) {
                            saw_store = true;
                            if (!is_constant_store(s)) {
                                all_const = false;
                                break;
                            }
                            int64_t v = LLVMConstIntGetSExtValue(LLVMGetOperand(s, 0));
                            if (!const_init) {
                                const_val = v;
                                const_init = true;
                            } else if (v != const_val) {
                                all_const = false;
                                break;
                            }
                        }
                    }

                    if (saw_store && all_const && const_init) {
                        LLVMTypeRef ty = LLVMTypeOf(inst);
                        LLVMValueRef c = LLVMConstInt(ty, static_cast<uint64_t>(const_val), 1);
                        LLVMReplaceAllUsesWith(inst, c);
                        loads_to_delete.push_back(inst);
                        changed = true;
                    }
                }
            }
        }

        for (auto *inst : loads_to_delete) {
            LLVMInstructionEraseFromParent(inst);
        }
    }

    return changed;
}

int main(int argc, char **argv) {
    bool enable_constprop = true;
    const char *input_path = nullptr;
    const char *output_path = nullptr;

    for (int i = 1; i < argc; ++i) {
        if (std::strcmp(argv[i], "--local") == 0) {
            enable_constprop = false;
        } else if (!input_path) {
            input_path = argv[i];
        } else if (!output_path) {
            output_path = argv[i];
        } else {
            std::fprintf(stderr, "Usage: %s [--local] <input.ll> [output.ll]\n", argv[0]);
            return 1;
        }
    }

    if (!input_path) {
        std::fprintf(stderr, "Usage: %s [--local] <input.ll> [output.ll]\n", argv[0]);
        return 1;
    }

    LLVMContextRef context = LLVMContextCreate();
    LLVMMemoryBufferRef buffer = nullptr;
    char *error = nullptr;

    if (LLVMCreateMemoryBufferWithContentsOfFile(input_path, &buffer, &error) != 0) {
        std::fprintf(stderr, "Error reading '%s': %s\n", input_path, error);
        LLVMDisposeMessage(error);
        LLVMContextDispose(context);
        return 2;
    }

    LLVMModuleRef module = nullptr;
    if (LLVMParseIRInContext(context, buffer, &module, &error) != 0) {
        std::fprintf(stderr, "Error parsing IR: %s\n", error);
        LLVMDisposeMessage(error);
        LLVMDisposeMemoryBuffer(buffer);
        LLVMContextDispose(context);
        return 3;
    }
    
    common_subexpr_elim_module(module);

    bool changed = true;
    while (changed) {
        changed = false;
        if (enable_constprop) {
            changed |= constant_propagation_module(module);
        }
        changed |= constant_fold_module(module);
    }

    dead_code_elim_module(module);
    set_module_id_from_input(module, input_path);

    if (output_path) {
        if (LLVMPrintModuleToFile(module, output_path, &error) != 0) {
            std::fprintf(stderr, "Error writing '%s': %s\n", output_path, error);
            LLVMDisposeMessage(error);
            LLVMDisposeModule(module);
            LLVMContextDispose(context);
            return 4;
        }
    } else {
        char *ir = LLVMPrintModuleToString(module);
        std::fputs(ir, stdout);
        LLVMDisposeMessage(ir);
    }

    LLVMDisposeModule(module);
    LLVMContextDispose(context);
    return 0;
}
