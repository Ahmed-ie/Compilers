# MiniC Optimizer (Part 3)

## Build
From this directory:

```sh
make
```

## Run
Local optimizations only (constant folding, CSE, DCE):

```sh
./optimizer --local ../tests/optimizations/cfold_add.ll > /tmp/out.ll
```

Global optimizations (constant propagation + folding to fix-point, then DCE):

```sh
./optimizer ../tests/optimizations/p4_const_prop.ll > /tmp/out.ll
```

Write to a file directly:

```sh
./optimizer ./tests/optimizations/p4_const_prop.ll /tmp/out.ll
```

CLI: `./optimizer [--local] <input.ll> [output.ll]` (prints to stdout if `output.ll` is omitted)

## Tests
Run the full test suite (ignores ModuleID and PIC Level diffs):

```sh
make test
```

## Notes
- Input is LLVM IR (`.ll`) generated by `clang` for the provided MiniC programs.
- Output is optimized LLVM IR printed to stdout (or to a file if you pass a second path).
- Some metadata (e.g., PIC level) can differ by LLVM version and is not optimization logic.
- `make test` ignores `ModuleID` and `PIC Level` lines in diffs (see `Makefile`).
- Use `--local` to disable constant propagation for local-only tests.

## Optimization Details
This optimizer runs the following passes in order:

1. Common subexpression elimination (CSE)
2. Constant folding
3. Dead code elimination (DCE)
4. Constant propagation + constant folding to fix-point (when `--local` is not set)
5. Final DCE

### Common Subexpression Elimination (CSE)
Within each basic block, instructions with the same opcode and operands are treated as
equivalent. The later instruction is replaced by the earlier one using
`LLVMReplaceAllUsesWith`. We do not eliminate `call`, `store`, `alloca`, or terminator
instructions.

Special case for `load`:
We only reuse a previous `load` from the same pointer if no intervening `store` to that
pointer has occurred in the block.

Example:
```llvm
%1 = add i32 %a, %b
%2 = add i32 %a, %b   ; replaced with %1
```

### Constant Folding
Arithmetic instructions with constant operands are evaluated at compile time.
Currently handles `add`, `sub`, `mul` on integer constants.

Example:
```llvm
%1 = add i32 10, 20   ; folded to i32 30
```

### Dead Code Elimination (DCE)
Removes instructions with no uses and no side effects.
We do not remove `store`, `call`, `alloca`, or terminator instructions.

### Constant Propagation (Store-Load Dataflow)
We compute GEN/KILL/IN/OUT sets of reaching `store` instructions. At each `load`,
if all reaching stores to that address write the same constant, the load is replaced
with that constant, then removed.

Example:
```llvm
store i32 100, ptr %p
%x = load i32, ptr %p   ; replaced with 100
```

Constant propagation is run in a fix-point loop with constant folding to expose
new optimization opportunities.

## Testing
`make test` runs the optimizer on all provided `.ll` files and diffs output against
the expected `*_opt.ll` files. The diff ignores `ModuleID` and `PIC Level` differences.
